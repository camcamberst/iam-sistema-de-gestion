import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { model_id, room_id, jornada, action } = body;

    if (!model_id || !room_id || !jornada || !action) {
      return NextResponse.json(
        { success: false, error: 'Faltan par√°metros requeridos' },
        { status: 400 }
      );
    }

    if (!['move', 'assign'].includes(action)) {
      return NextResponse.json(
        { success: false, error: 'Acci√≥n inv√°lida. Debe ser "move" o "assign"' },
        { status: 400 }
      );
    }

    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    if (action === 'move') {
      // MOVER: Desactivar todas las asignaciones existentes del modelo
      const { error: deactivateError } = await supabase
        .from('modelo_assignments')
        .update({ is_active: false })
        .eq('model_id', model_id)
        .eq('is_active', true);

      if (deactivateError) {
        console.error('Error desactivando asignaciones existentes:', deactivateError);
        return NextResponse.json(
          { success: false, error: 'Error desactivando asignaciones existentes' },
          { status: 500 }
        );
      }

      console.log(`‚úÖ [API] Asignaciones existentes desactivadas para modelo ${model_id}`);
    }

    // Verificar si ya existe una asignaci√≥n activa en el mismo room/jornada
    // PERO solo si es de un modelo DIFERENTE (para permitir "doblar" del mismo modelo)
    const { data: existingAssignment, error: checkError } = await supabase
      .from('modelo_assignments')
      .select('id, model_id')
      .eq('room_id', room_id)
      .eq('jornada', jornada)
      .eq('is_active', true)
      .neq('model_id', model_id); // Excluir el modelo actual

    if (checkError) {
      console.error('Error verificando asignaciones existentes:', checkError);
      return NextResponse.json(
        { success: false, error: 'Error verificando asignaciones existentes' },
        { status: 500 }
      );
    }

    // Solo rechazar si hay OTRA modelo (diferente) asignada en el mismo room/jornada
    if (existingAssignment && existingAssignment.length > 0) {
      return NextResponse.json(
        { success: false, error: 'Ya hay otra modelo asignada en este room y jornada' },
        { status: 400 }
      );
    }

    // TEMPORALMENTE DESHABILITADO: Verificar si el mismo modelo ya est√° asignado en la misma jornada
    // Esta validaci√≥n est√° causando problemas con asignaciones fantasma
    console.log('‚ö†Ô∏è [API] Validaci√≥n de duplicados deshabilitada temporalmente');
    
    // TODO: Rehabilitar esta validaci√≥n una vez que se resuelva el problema de asignaciones fantasma
    /*
    const { data: sameModelAssignment, error: sameModelError } = await supabase
      .from('modelo_assignments')
      .select('id, model_id')
      .eq('room_id', room_id)
      .eq('jornada', jornada)
      .eq('model_id', model_id)
      .eq('is_active', true);

    if (sameModelError) {
      console.error('Error verificando asignaci√≥n del mismo modelo:', sameModelError);
      return NextResponse.json(
        { success: false, error: 'Error verificando asignaci√≥n del mismo modelo' },
        { status: 500 }
      );
    }

    // Si el mismo modelo ya est√° asignado en la misma jornada, rechazar
    if (sameModelAssignment && sameModelAssignment.length > 0) {
      return NextResponse.json(
        { success: false, error: 'Esta modelo ya est√° asignada en esta jornada' },
        { status: 400 }
      );
    }
    */

    // Crear nueva asignaci√≥n
    const { data: newAssignment, error: insertError } = await supabase
      .from('modelo_assignments')
      .insert({
        model_id,
        room_id,
        jornada,
        is_active: true,
        assigned_at: new Date().toISOString()
      })
      .select()
      .single();

    if (insertError) {
      console.error('Error creando nueva asignaci√≥n:', insertError);
      return NextResponse.json(
        { success: false, error: 'Error creando nueva asignaci√≥n' },
        { status: 500 }
      );
    }

    console.log(`‚úÖ [API] Nueva asignaci√≥n creada:`, {
      model_id,
      room_id,
      jornada,
      action,
      assignment_id: newAssignment.id
    });

    return NextResponse.json({
      success: true,
      message: `Modelo ${action === 'move' ? 'movida' : 'asignada'} exitosamente`,
      assignment: newAssignment
    });

  } catch (error) {
    console.error('Error en POST /api/assignments:', error);
    return NextResponse.json(
      { success: false, error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const body = await request.json();
    const { assignment_id } = body;

    console.log('üóëÔ∏è [API] DELETE request recibido:', { body, assignment_id });

    if (!assignment_id) {
      console.log('‚ùå [API] ID de asignaci√≥n faltante');
      return NextResponse.json(
        { success: false, error: 'ID de asignaci√≥n requerido' },
        { status: 400 }
      );
    }

    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    console.log(`üóëÔ∏è [API] Eliminando asignaci√≥n ID: ${assignment_id}`);

    // Primero verificar que la asignaci√≥n existe y est√° activa
    const { data: existingAssignment, error: checkError } = await supabase
      .from('modelo_assignments')
      .select('id, is_active, model_id, jornada')
      .eq('id', assignment_id)
      .single();

    if (checkError) {
      console.error('‚ùå [API] Error verificando asignaci√≥n:', checkError);
      return NextResponse.json(
        { success: false, error: 'Asignaci√≥n no encontrada' },
        { status: 404 }
      );
    }

    console.log('üîç [API] Asignaci√≥n encontrada:', existingAssignment);

    if (!existingAssignment.is_active) {
      console.log('‚ö†Ô∏è [API] Asignaci√≥n ya est√° inactiva');
      return NextResponse.json(
        { success: false, error: 'Asignaci√≥n ya est√° eliminada' },
        { status: 400 }
      );
    }

    // Desactivar la asignaci√≥n (soft delete)
    const { data: updateResult, error: deactivateError } = await supabase
      .from('modelo_assignments')
      .update({ is_active: false })
      .eq('id', assignment_id)
      .select();

    if (deactivateError) {
      console.error('‚ùå [API] Error desactivando asignaci√≥n:', deactivateError);
      return NextResponse.json(
        { success: false, error: 'Error eliminando asignaci√≥n' },
        { status: 500 }
      );
    }

    console.log('‚úÖ [API] Asignaci√≥n desactivada:', updateResult);
    console.log(`‚úÖ [API] Asignaci√≥n ${assignment_id} eliminada exitosamente`);

    return NextResponse.json({
      success: true,
      message: 'Asignaci√≥n eliminada exitosamente',
      deleted_assignment: updateResult
    });

  } catch (error) {
    console.error('‚ùå [API] Error en DELETE /api/assignments:', error);
    return NextResponse.json(
      { success: false, error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
}
